# -*- coding: utf-8 -*-
"""NEC2_py8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NtDfI_EjEDihyGEN17mjT2Gv9_e4DI6H

# BIBLIOTECAS
"""

!pip install pynec

#NEC2C
!apt-get install nec2c

"""# DIAGRAMA DE RADIAÇÃO PARA CADA FREQ. DO DATASHEET

Funcionamento arquivo NEC:
## Explicação Linha por Linha do Arquivo de Entrada NEC (LINHA 8 da celula abaixo)

### 1. `CM Teste Monopolo Vertical`
- `CM` é o comando de comentário no NEC. Tudo o que segue após esse comando é tratado como comentário.
- Neste caso, você está identificando o arquivo como "Teste Monopolo Vertical".

### 2. `CE`
- `CE` encerra a seção de comentários no arquivo. Após esse comando, o NEC2 começará a interpretar os comandos.

### 3. `GW 1 20 0 0 0 0 0 4.6 0.005`
- `GW` define um elemento condutor (um fio).
  - `1`: Identificador do fio (ou tag number).
  - `20`: Número de segmentos em que o fio será dividido. O NEC2 usa esses segmentos para calcular o comportamento da corrente ao longo do fio.
  - `0 0 0`: Coordenadas da primeira extremidade do fio (x1, y1, z1).
  - `0 0 4.6`: Coordenadas da segunda extremidade do fio (x2, y2, z2). Aqui, o fio tem uma altura de 4,6 metros.
  - `0.005`: Raio do fio em metros (5 mm).

### 4. `GE 0`
- `GE` define a geometria da antena.
  - `0`: Aqui, o valor `0` indica que não há segmentação extra ou outras operações geométricas, apenas a geometria direta do fio.

### 5. `GN 2 0 0 0 13 0.005`
- `GN` define o ambiente de solo (ground parameters).
  - `2`: Define um solo finito com solução Sommerfeld.
  - `13`: Constante dielétrica relativa do solo.
  - `0.005`: Condutividade do solo em siemens por metro (S/m).

### 6. `EK`
- `EK` ativa o kernel estendido para o cálculo de fio fino (extended thin wire kernel). Isso melhora a precisão dos cálculos para fios finos, como o monopolo.

### 7. `EX 0 1 10 0 1 0`
- `EX` define a excitação (fonte de alimentação) da antena.
  - `0`: Tipo de excitação (campo elétrico no terminal).
  - `1`: Identificador do fio onde a excitação será aplicada.
  - `10`: Número do segmento do fio onde a excitação será aplicada (neste caso, no meio do fio).
  - `1 0`: Os próximos números representam a amplitude e a fase da excitação (1 volt, 0 graus de fase).

### 8. `FR 0 1 0 0 {frequency} 0`
- `FR` define a frequência de operação.
  - `0`: Indica que é uma varredura de frequência simples.
  - `1`: Número de passos de frequência (neste caso, um único passo).
  - `{frequency}`: Frequência em MHz.

### 9. `RP 0 91 1 1000 0 0 5 5 0 0`
- `RP` define os parâmetros de radiação, ou seja, como o diagrama de radiação será calculado.
  - `0`: Indica que a radiação será calculada em um plano cartesiano.
  - `91`: Número de ângulos (pontos) na malha de cálculo.
  - `1`: Número de planos de radiação.
  - `1000`: Incremento no ângulo de azimute (em milésimos de grau).
  - `5 5`: Incrementos no ângulo de elevação e azimute, respectivamente.

### 10. `EN`
- `EN` finaliza a entrada de dados e começa a execução do código NEC2.
"""

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Arquivo NEC
def generate_nec_input(frequency):
    return f"""
CM Teste Monopolo Vertical
CE

GW 1 20 0 0 0 0 0 4.6 0.005
GE 0
GN 2 0 0 0 13 0.005
EK
EX 0 1 10 0 1 0
FR 0 1 0 0 {frequency} 0
RP 0 91 1 1000 0 0 5 5 0 0
EN
"""

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # ~Solo seco
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Plotar o diagrama de radiação
def plot_radiation_diagram(frequency, theta, gain_perfect, gain_dry):
    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Gráfico polar
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label="Solo Condutor Perfeito", color="blue")
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label="Solo Seco", color="blue")

    # Config. do gráfico
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)
    ax.set_ylim(-20, 10)
    ax.set_yticks(np.arange(-20, 15, 5))
    ax.set_thetamin(270)
    ax.set_thetamax(90)
    ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90])) #aqui repete o 360 e 0 pra fechar
    ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
    ax.set_title(f"Diagrama de Radiação - {frequency} MHz", va='bottom')

    # Legenda
    ax.legend(loc="upper right")

    plt.show()

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Faz a varredura em cada frequencia -> Simula e plota para cada frequência
for freq in frequencies:
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abr e edita o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica a saída e erros
    print(f"Resultado para {freq} MHz:")
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
        print(f"Arquivo {output_filename} encontrado.")
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue  # procura os arquivos nec

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # Plota o diagrama de radiação
    plot_radiation_diagram(freq, theta, gain_perfect, gain_dry)

"""## COM OS RADIAIS"""

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Função para gerar o arquivo de entrada NEC com ground screen
def generate_nec_input(frequency):
    num_radials = 4  # Número de radiais para o ground screen
    radial_length = 4.6  # Comprimento de cada radial (em metros)
    radial_radius = 0.005  # Raio de cada radial (em metros)

    # Definição do monopolo vertical
    nec_input = f"""
CM Teste Monopolo Vertical com Ground Screen
CE

GW 1 20 0 0 0 0 0 4.6 {radial_radius}  # Monopolo vertical
GE 0
GN 2 0 0 0 13 0.005
EK
EX 0 1 10 0 1 0
FR 0 1 0 0 {frequency} 0
RP 0 181 1 1000 0 0 1 5 0 0  # Alterado para solicitar padrão de radiação completo
EN
"""

    # Adiciona os radiais do ground screen
    for i in range(num_radials):
        angle = i * (360 / num_radials)
        x2 = radial_length * np.cos(np.radians(angle))
        y2 = radial_length * np.sin(np.radians(angle))
        nec_input += f"GW {i+2} 1 0 0 0 {x2:.6f} {y2:.6f} 0 {radial_radius}\n"

    nec_input += "EN\n"

    return nec_input

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # Aproximação para solo seco
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Plotar o diagrama de radiação
def plot_radiation_diagram(frequency, theta, gain_perfect, gain_dry):
    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Gráfico polar
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label="Solo Condutor Perfeito", color="blue")
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label="Solo Seco", color="blue")

    # Configurações do gráfico
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)
    ax.set_ylim(-20, 10)
    ax.set_yticks(np.arange(-20, 15, 5))
    ax.set_thetamin(270)
    ax.set_thetamax(90)
    ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90]))  # ângulos de 270° a 90°
    ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
    ax.set_title(f"Diagrama de Radiação - {frequency} MHz", va='bottom')

    # Legenda
    ax.legend(loc="upper right")

    plt.show()

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Faz a varredura em cada frequência -> Simula e plota para cada frequência
for freq in frequencies:
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abr e edita o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica a saída e erros
    print(f"Resultado para {freq} MHz:")
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
        print(f"Arquivo {output_filename} encontrado.")
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue  # procura os arquivos nec

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # Plota o diagrama de radiação
    if theta:  # Somente plota se houver dados
        plot_radiation_diagram(freq, theta, gain_perfect, gain_dry)
    else:
        print(f"Aviso: Nenhum dado de radiação encontrado para {freq} MHz.")

"""## Proximo do datasheet"""

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Função para gerar o arquivo de entrada NEC com ground screen
def generate_nec_input(frequency):
    num_radials = 4  # Número de radiais para o ground screen
    radial_length = 4.6  # Comprimento de cada radial (em metros)
    radial_radius = 0.005  # Raio de cada radial (em metros)

    # Definição do monopolo vertical
    nec_input = f"""
CM Teste Monopolo Vertical com Ground Screen
CE

GW 1 20 0 0 0 0 0 4.6 {radial_radius}  # Monopolo vertical
GE 0
GN 2 0 0 0 13 0.005
EK
EX 0 1 10 0 1 0
FR 0 1 0 0 {frequency} 0
RP 0 181 1 1000 0 0 1 5 0 0  # ALTERADO PARA SOLICITAR PADRÃO DE RADIAÇÃO COMPLETO (MAIOR RESOLUÇÃO)
EN
"""

    # Adiciona os radiais do ground screen
    for i in range(num_radials):
        angle = i * (360 / num_radials)
        x2 = radial_length * np.cos(np.radians(angle))
        y2 = radial_length * np.sin(np.radians(angle))
        nec_input += f"GW {i+2} 1 0 0 0 {x2:.6f} {y2:.6f} 0 {radial_radius}\n"

    nec_input += "EN\n"

    return nec_input

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # APROXIMAÇÃO PARA SOLO SECO
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Plotar o diagrama de radiação
def plot_radiation_diagram(frequency, theta, gain_perfect, gain_dry):
    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Gráfico polar
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label="Solo Condutor Perfeito", color="blue")
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label="Solo Seco", color="blue")

    # Configurações do gráfico
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)
    ax.set_ylim(-20, 10)  # AJUSTAMOS O RANGE DE GANHO PARA SER MAIS VISUALMENTE PRÓXIMO AO DO DATASHEET
    ax.set_yticks(np.arange(-20, 15, 5))
    ax.set_thetamin(270)
    ax.set_thetamax(90)
    ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90]))  # ÂNGULOS DE 270° A 90°
    ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
    ax.set_title(f"Diagrama de Radiação - {frequency} MHz", va='bottom')

    # Legenda
    ax.legend(loc="upper right")

    plt.show()

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Faz a varredura em cada frequência -> Simula e plota para cada frequência
for freq in frequencies:
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abr e edita o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica a saída e erros
    print(f"Resultado para {freq} MHz:")
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
        print(f"Arquivo {output_filename} encontrado.")
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue  # Procura os arquivos NEC

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # Plota o diagrama de radiação
    if theta:  # SOMENTE PLOTA SE HOUVER DADOS
        plot_radiation_diagram(freq, theta, gain_perfect, gain_dry)
    else:
        print(f"Aviso: Nenhum dado de radiação encontrado para {freq} MHz.")

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Função para gerar o arquivo de entrada NEC com ground screen ajustado
def generate_nec_input(frequency):
    num_radials = 36  # Número de radiais para o ground screen
    radial_length = 10.0  # Comprimento de cada radial (em metros), conforme o datasheet
    radial_radius = 0.005  # Raio de cada radial (em metros)

    # Definição do monopolo vertical
    nec_input = f"""
CM Teste Monopolo Vertical com Ground Screen Ajustado
CE

GW 1 20 0 0 0 0 0 4.6 {radial_radius}  # Monopolo vertical, altura de 4,6 metros
GE 0
GN 2 0 0 0 13 0.005  # Solo perfeito
EK
EX 0 1 10 0 1 0  # Alimentação do monopolo
FR 0 1 0 0 {frequency} 0  # Frequência de operação
RP 0 181 1 1000 0 0 1 5 0 0  # Padrão de radiação completo (0 a 180 graus)
EN
"""

    # Adiciona os 36 radiais do ground screen
    for i in range(num_radials):
        angle = i * (360 / num_radials)
        x2 = radial_length * np.cos(np.radians(angle))
        y2 = radial_length * np.sin(np.radians(angle))
        nec_input += f"GW {i+2} 1 0 0 0 {x2:.6f} {y2:.6f} 0 {radial_radius}\n"

    nec_input += "EN\n"

    return nec_input

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # Aproximação para solo seco
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Plotar o diagrama de radiação
def plot_radiation_diagram(frequency, theta, gain_perfect, gain_dry):
    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Gráfico polar
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label="Solo Condutor Perfeito", color="blue")
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label="Solo Seco", color="blue")

    # Configurações do gráfico
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)
    ax.set_ylim(-20, 10)  # Ajustamos o range de ganho para ser mais visualmente próximo ao do datasheet
    ax.set_yticks(np.arange(-20, 15, 5))
    ax.set_thetamin(270)
    ax.set_thetamax(90)
    ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90]))  # Ângulos de 270° a 90°
    ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
    ax.set_title(f"Diagrama de Radiação - {frequency} MHz", va='bottom')

    # Legenda
    ax.legend(loc="upper right")

    plt.show()

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Faz a varredura em cada frequência -> Simula e plota para cada frequência
for freq in frequencies:
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abr e edita o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica a saída e erros
    print(f"Resultado para {freq} MHz:")
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
        print(f"Arquivo {output_filename} encontrado.")
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue  # Procura os arquivos NEC

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # Plota o diagrama de radiação
    if theta:  # Somente plota se houver dados
        plot_radiation_diagram(freq, theta, gain_perfect, gain_dry)
    else:
        print(f"Aviso: Nenhum dado de radiação encontrado para {freq} MHz.")

"""## RADIAIS CERTOS!"""

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Função para gerar o arquivo de entrada NEC com ground screen ajustado
def generate_nec_input(frequency):
    num_radials = 36  # Número de radiais para o ground screen
    radial_length = 10.0  # Comprimento de cada radial (em metros), conforme o datasheet
    radial_radius = 0.005  # Raio de cada radial (em metros)

    # Definição do monopolo vertical
    nec_input = f"""
CM Teste Monopolo Vertical com Ground Screen Ajustado
CE

GW 1 20 0 0 0 0 0 4.6 {radial_radius}  # Monopolo vertical, altura de 4,6 metros
GE 0
GN 2 0 0 0 13 0.005  # Solo perfeito
EK
EX 0 1 10 0 1 0  # Alimentação do monopolo
FR 0 1 0 0 {frequency} 0  # Frequência de operação
RP 0 181 1 1000 0 0 1 5 0 0  # Padrão de radiação completo (0 a 180 graus)
EN
"""

    # Adiciona os 36 radiais do ground screen
    for i in range(num_radials):
        angle = i * (360 / num_radials)
        x2 = radial_length * np.cos(np.radians(angle))
        y2 = radial_length * np.sin(np.radians(angle))
        nec_input += f"GW {i+2} 1 0 0 0 {x2:.6f} {y2:.6f} 0 {radial_radius}\n"

    nec_input += "EN\n"

    return nec_input

# Função para normalizar o ganho
def normalize_gain(gain):
    gain_max = max(gain)
    return [g - gain_max + 10 for g in gain]  # Normaliza para que o máximo seja 10 dB

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # Aproximação para solo seco
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Plotar o diagrama de radiação
def plot_radiation_diagram(frequency, theta, gain_perfect, gain_dry):
    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Gráfico polar
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label="Solo Condutor Perfeito", color="blue")
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label="Solo Seco", color="red")  # Corrigido para plotar o solo seco

    # Configurações do gráfico
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)
    ax.set_ylim(-20, 10)  # Ajustamos o range de ganho para ser mais visualmente próximo ao do datasheet
    ax.set_yticks(np.arange(-20, 15, 5))
    ax.set_thetamin(270)
    ax.set_thetamax(90)
    ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90]))  # Ângulos de 270° a 90°
    ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
    ax.set_title(f"Diagrama de Radiação - {frequency} MHz", va='bottom')

    # Legenda
    ax.legend(loc="upper right")

    plt.show()

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Faz a varredura em cada frequência -> Simula e plota para cada frequência
for freq in frequencies:
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abr e edita o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica a saída e erros
    print(f"Resultado para {freq} MHz:")
    print("STDOUT:", result.stdout)
    print("STDERR:", result.stderr)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
        print(f"Arquivo {output_filename} encontrado.")
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue  # Procura os arquivos NEC

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # Plota o diagrama de radiação
    if theta:  # Somente plota se houver dados
        plot_radiation_diagram(freq, theta, gain_perfect, gain_dry)
    else:
        print(f"Aviso: Nenhum dado de radiação encontrado para {freq} MHz.")

# Exibe o conteúdo completo do arquivo de saída .out
output_filename = "monopole_3.0MHz.out"  # Substitua pelo nome do arquivo desejado
with open(output_filename, "r") as f:
    output_data = f.read()
print(output_data)

# Exibir mais linhas do arquivo monopole_3.0MHz.out para análise
output_filename = "monopole_3.0MHz.out"

try:
    with open(output_filename, "r") as f:
        output_data = f.read()
    print(f"Conteúdo completo do arquivo {output_filename}:\n")
    print(output_data)  # Exibir o conteúdo completo do arquivo para análise
except FileNotFoundError:
    print(f"Arquivo {output_filename} não encontrado!")



"""## COM TODOS OS PLOTS SOBREPOSTOS (SEM OS RADIAIS)"""

import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Arquivo NEC
def generate_nec_input(frequency):
    return f"""
CM Teste Monopolo Vertical
CE

GW 1 20 0 0 0 0 0 4.6 0.005
GE 0
GN 2 0 0 0 13 0.005
EK
EX 0 1 10 0 1 0
FR 0 1 0 0 {frequency} 0
RP 0 91 1 1000 0 0 5 5 0 0
EN
"""

# Extrai os dados de radiação do arquivo de saída
def extract_radiation_pattern(output_data):
    lines = output_data.splitlines()
    start_index = 0
    for i, line in enumerate(lines):
        if "RADIATION PATTERNS" in line:
            start_index = i + 2
            break

    theta = []
    gain_perfect_ground = []
    gain_dry_ground = []

    for line in lines[start_index:]:
        if not line.strip():
            break
        data = line.split()
        try:
            angle = float(data[0])
            gain_perfect = float(data[4])
            gain_dry = gain_perfect - 5  # ~Solo seco
            theta.append(angle)
            gain_perfect_ground.append(gain_perfect)
            gain_dry_ground.append(gain_dry)
        except ValueError:
            continue

    return theta, gain_perfect_ground, gain_dry_ground

# Frequências do datasheet
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]
colors = ['blue', 'green', 'red', 'purple', 'orange', 'cyan']

# Gráfico polar
fig, ax = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(10, 8))

# Processar cada frequência
for i, freq in enumerate(frequencies):
    # Gera o arquivo de entrada NEC
    nec_input = generate_nec_input(freq)

    # Nomeia o arquivo de entrada e saída de acordo com a frequência
    nec_filename = f"monopole_{freq}MHz.nec"
    output_filename = f"monopole_{freq}MHz.out"

    # Abrir e editar o arquivo de entrada NEC
    with open(nec_filename, "w") as f:
        f.write(nec_input)

    # Roda o Nec2c com o arquivo de entrada gerado
    result = subprocess.run(['nec2c', '-i', nec_filename, '-o', output_filename], capture_output=True, text=True)

    # Verifica se o arquivo de saída foi gerado
    try:
        with open(output_filename, "r") as f:
            output_data = f.read()
    except FileNotFoundError:
        print(f"Arquivo de saída {output_filename} não encontrado!")
        continue

    # Extrai os dados de radiação
    theta, gain_perfect, gain_dry = extract_radiation_pattern(output_data)

    # 0 a 90 graus
    theta_right = np.linspace(0, 90, 91)
    gain_perfect_right = np.interp(theta_right, theta, gain_perfect)
    gain_dry_right = np.interp(theta_right, theta, gain_dry)

    # 270 a 360 graus
    theta_left = np.linspace(270, 360, 91)
    gain_perfect_left = np.flip(gain_perfect_right)
    gain_dry_left = np.flip(gain_dry_right)

    # Combinação
    theta_full = np.concatenate((theta_left, theta_right[1:]))
    gain_perfect_full = np.concatenate((gain_perfect_left, gain_perfect_right[1:]))
    gain_dry_full = np.concatenate((gain_dry_left, gain_dry_right[1:]))

    # Converte os ângulos para radianos
    theta_radians = np.radians(theta_full)

    # Plotar os dados
    ax.plot(theta_radians, gain_perfect_full, label=f"{freq} MHz - Solo Condutor Perfeito", color=colors[i])
    ax.plot(theta_radians, gain_dry_full, linestyle='--', label=f"{freq} MHz - Solo Seco", color=colors[i])

# Configurações estéticas do gráfico
ax.set_theta_zero_location('N')
ax.set_theta_direction(-1)
ax.set_ylim(-20, 10)
ax.set_yticks(np.arange(-20, 15, 5))
ax.set_thetamin(270)
ax.set_thetamax(90)
ax.set_xticks(np.radians([270, 300, 330, 360, 0, 30, 60, 90]))
ax.set_xticklabels(['270°', '300°', '330°', '0°', '0°', '30°', '60°', '90°'])
ax.set_title("Diagrama de Radiação - Frequências Variadas", va='bottom')

# Legenda
ax.legend(loc="upper right")

# Mostrar o gráfico
plt.show()

"""# RELATORIO ENGINE NEC2C

Exemplo para o 10 MHz
"""

# Verifica o conteúdo do arquivo monopole_10.0MHz.out
output_filename = "/content/monopole_10.0MHz.out"

with open(output_filename, "r") as f:
    output_data = f.read()

# Relatorio NEC - Exibir todo o conteúdo do arquivo
print(output_data)

# Relatorio NEC (50 primeiras linhas)
# print("\n".join(output_data.splitlines()[:50]))

"""# RELATORIO FREQ, GANHO, IMPEDANCIA REAL E IMAG"""

import os
import numpy as np
import pandas as pd

# Extrair o ganho isotrópico e outras info do arquivo de saída
def extract_gain_impedance(output_data):
    lines = output_data.splitlines()
    gain_isotropic = None
    impedance_real = None
    impedance_imag = None

    # Busca ganho isotrópico e impedância no arquivo
    for i, line in enumerate(lines):
        if "VERTC" in line:
            print(f"Encontrado 'VERTC' na linha {i}: {line}")  # Debug
            # Força busca de ganho isotrópico
            try:
                # Força extração dos ganhos (ignorando cabeçalhos)
                for j in range(i+1, len(lines)):
                    if lines[j].strip() and lines[j].split()[0].replace('.', '', 1).isdigit():
                        gain_value = float(lines[j].split()[4])  # Ganho TOTAL
                        if gain_isotropic is None or gain_value > gain_isotropic:
                            gain_isotropic = gain_value
            except Exception as e:
                print(f"Erro ao calcular o ganho isotrópico: {e}")
                gain_isotropic = None

        if "ANTENNA INPUT PARAMETERS" in line:
            print(f"Encontrado 'ANTENNA INPUT PARAMETERS' na linha {i}: {line}")  # Debug
            # Força busca da impedância da antena
            for j in range(i+2, len(lines)):  # Após a linha do cabeçalho
                data_line = lines[j].split()
                if len(data_line) >= 6 and data_line[0].replace('.', '', 1).isdigit():
                    try:
                        impedance_real = float(data_line[4])
                        impedance_imag = float(data_line[5])
                        break  # Já extraímos os dados, podemos sair do loop
                    except Exception as e:
                        print(f"Erro ao extrair impedância: {e}")
                        impedance_real = None
                        impedance_imag = None

    return gain_isotropic, impedance_real, impedance_imag

# Frequências para buscar
frequencies = [3.0, 5.0, 10.0, 15.0, 20.0, 25.0]

# Tabela para armazenar os resultados
results_table = []

# Verifica e extrai as informações dos arquivos .out gerados
for freq in frequencies:
    output_filename = f"monopole_{freq}MHz.out"

    if os.path.exists(output_filename):
        with open(output_filename, "r") as f:
            output_data = f.read()

        # Extrai informações de ganho e impedância
        gain_isotropic, impedance_real, impedance_imag = extract_gain_impedance(output_data)

        # Adiciona os dados na tabela
        results_table.append({
            "Frequência (MHz)": freq,
            "Ganho Isotrópico (dB)": gain_isotropic,
            "Impedância Real (Ohms)": impedance_real,
            "Impedância Imaginária (Ohms)": impedance_imag
        })
    else:
        print(f"Arquivo {output_filename} não encontrado.")

# Exibe a tabela de resultados
results_df = pd.DataFrame(results_table)
print(results_df)